---
description: Defines rules for generating UI components based on EventStorming stickers. Includes integration with MSA backend and Vuetify UI framework utilization.
alwaysApply: false
---

## Command
0. Essential Reference Note
You must proceed with axios calls and button configuration by referring to api/openapi.yaml or openapi.yaml files within each service folder.


1. Reference Metadata
Command uses 'commands' metadata and is implemented as button forms in the UI. Each Command is generated as a button component that triggers user actions.

2. Generated Files
CommandButton.vue
File name: Command sticker name + Button.vue
Structure:
- Button UI component
- Click event handler
- API call logic (utilizing Composables)
- Loading state and error handling
- Button styling (based on Vuetify/Element Plus)

CommandComposable.ts
File name: Command sticker name + Command.composable.ts
Structure:
- API call functions
- State management (loading, error, success)
- Form data validation (utilizing VeeValidate)

3. Button Generation Rules
Implement as Vuetify button components to match backend REST API.

**Vuetify 버튼 컴포넌트 활용:**
```vue
<template>
  <v-btn 
    :color="buttonConfig.color"
    :variant="buttonConfig.variant"
    :loading="loading"
    :disabled="disabled"
    @click="handleCommand"
  >
    <v-icon start>{{ buttonConfig.icon }}</v-icon>
    {{ buttonConfig.label }}
  </v-btn>
</template>

<script setup>
import { computed } from 'vue'
import { useCommandComposable } from '@/composables/[context]/[command].composable'

const props = defineProps({
  aggregateId: String,
  commandData: Object
})

const { execute, loading, error } = useCommandComposable()

const buttonConfig = computed(() => ({
  create: { color: 'primary', icon: 'mdi-plus', label: 'Create', variant: 'elevated' },
  update: { color: 'info', icon: 'mdi-pencil', label: 'Update', variant: 'tonal' },
  delete: { color: 'error', icon: 'mdi-delete', label: 'Delete', variant: 'outlined' }
}[props.commandType] || {}))
</script>
```

Button Generation Logic:
```typescript
// Default CUD buttons are always generated
const defaultButtons = ['Create', 'Update', 'Delete'];

// Check Command metadata
commands.forEach(command => {
  if (command.isRestRepository !== true) {
    // Create custom button using controllerInfo
    const customButton = {
      name: command.name,
      endpoint: `/${aggregate.namePlural}/${command.controllerInfo.apiPath}`,
      method: command.controllerInfo.method,
      description: command.description
    };
    // Generate custom button component
  }
});
```

Generated Button Component Structure:
- Default CUD buttons: Use standard REST API endpoints (/{aggregate.namePlural})
- Custom buttons: Use endpoints combining aggregate.namePlural and controllerInfo.apiPath (/{aggregate.namePlural}/{controllerInfo.apiPath})
- Independent loading state and error handling for each button
- Button enable/disable condition settings

4. Create/Update Button Dialog Handling
Generate dialog modal when Create(C) and Update(U) buttons are clicked:

Dialog Internal Field Configuration Rules:
- For default CU buttons: Configure Aggregate's properties (fieldDescriptors) as dialog internal fields
- For Commands where isRestRepository is not true: Configure properties defined in Command's internal fieldDescriptors as dialog internal fields

Dialog Generation Logic:
```typescript
// Generate dialog when Create/Update button is clicked
const openDialog = (buttonType: 'create' | 'update', command?: Command) => {
  let dialogFields = [];
  
  if (command && command.isRestRepository !== true) {
    // Use Command's fieldDescriptors
    dialogFields = command.fieldDescriptors || [];
  } else {
    // Use Aggregate's fieldDescriptors (default CU)
    dialogFields = aggregate.fieldDescriptors || [];
  }
  
  // Generate dialog modal and render fields
  createFormDialog({
    title: buttonType === 'create' ? `Create ${aggregate.name}` : `Update ${aggregate.name}`,
    fields: dialogFields,
    onSubmit: (formData) => handleSubmit(buttonType, formData, command)
  });
};
```

Dialog Component Structure:
- Modal/Dialog component (based on Vuetify/Element Plus)
- Dynamic form field generation (based on fieldDescriptors)
- Form validation using VeeValidate
- Submit/Cancel buttons
- Loading state and error message display


## Aggregate

1. Reference Metadata
Aggregate is generated as List-type components based on 'aggregates' metadata. It displays properties using fieldDescriptors and configures relational data (Enumeration, ValueObject, Entity) as tables or cards.

2. Generated Files
AggregateList.vue
File name: Aggregate name + List.vue
Structure:
- Data table/card list component
- Column/field configuration based on fieldDescriptors
- Search, filtering, sorting functionality
- Pagination
- CRUD action buttons
- Detail view modal/router integration

AggregateStore.ts
File name: Aggregate name + Store.ts
Structure:
- Pinia store definition
- Aggregate data state management
- API call actions
- Getter functions

## BoundedContext and Main Page Configuration

1. Main Page Configuration - Utilizing Vuetify Components

**MainDashboard.vue - Vuetify Grid 및 Card 활용**
```vue
<template>
  <v-container fluid>
    <!-- Header area -->
    <v-row>
      <v-col>
        <h1 class="text-h3 mb-4">{{ systemName }} Dashboard</h1>
      </v-col>
    </v-row>
    
    <!-- Statistics cards -->
    <v-row>
      <v-col v-for="stat in statistics" :key="stat.title" cols="12" sm="6" md="3">
        <v-card>
          <v-card-text>
            <div class="d-flex align-center">
              <v-icon :color="stat.color" size="48" class="mr-4">
                {{ stat.icon }}
              </v-icon>
              <div>
                <p class="text-caption mb-1">{{ stat.title }}</p>
                <p class="text-h5 font-weight-bold">{{ stat.value }}</p>
              </div>
            </div>
          </v-card-text>
        </v-card>
      </v-col>
    </v-row>
    
    <!-- BoundedContext cards -->
    <v-row class="mt-4">
      <v-col>
        <h2 class="text-h4 mb-4">Service Areas</h2>
      </v-col>
    </v-row>
    
    <v-row>
      <v-col 
        v-for="context in boundedContexts" 
        :key="context.name"
        cols="12" 
        md="6" 
        lg="4"
      >
        <v-card 
          :to="context.path"
          hover
          class="h-100"
        >
          <v-card-title>
            <v-icon :icon="context.icon" class="mr-2"></v-icon>
            {{ context.displayName }}
          </v-card-title>
          
          <v-card-subtitle>
            {{ context.aggregates.length }} Aggregates
          </v-card-subtitle>
          
          <v-card-text>
            <p class="mb-2">{{ context.description }}</p>
            <v-chip-group>
              <v-chip 
                v-for="agg in context.aggregates.slice(0, 3)" 
                :key="agg.name"
                size="small"
                variant="outlined"
              >
                {{ agg.displayName }}
              </v-chip>
              <v-chip 
                v-if="context.aggregates.length > 3"
                size="small"
                variant="outlined"
              >
                +{{ context.aggregates.length - 3 }} more
              </v-chip>
            </v-chip-group>
          </v-card-text>
          
          <v-card-actions>
            <v-btn 
              variant="text" 
              color="primary"
              append-icon="mdi-arrow-right"
            >
              Go to
            </v-btn>
          </v-card-actions>
        </v-card>
      </v-col>
    </v-row>
    
    <!-- Recent activities -->
    <v-row class="mt-4">
      <v-col>
        <h2 class="text-h4 mb-4">Recent Activities</h2>
        <v-card>
          <v-list lines="two">
            <v-list-item
              v-for="activity in recentActivities"
              :key="activity.id"
              :subtitle="activity.description"
            >
              <template v-slot:prepend>
                <v-icon :icon="activity.icon" :color="activity.color"></v-icon>
              </template>
              <template v-slot:title>
                {{ activity.title }}
                <v-chip size="x-small" class="ml-2">{{ activity.context }}</v-chip>
              </template>
              <template v-slot:append>
                <span class="text-caption">{{ formatTime(activity.timestamp) }}</span>
              </template>
            </v-list-item>
          </v-list>
        </v-card>
      </v-col>
    </v-row>
  </v-container>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { useRouter } from 'vue-router'

const router = useRouter()

// Generate BoundedContext based on metadata
const boundedContexts = computed(() => 
  generateBoundedContextsFromMetadata(metaData.boundedContexts)
)

// Statistics data
const statistics = ref([
  { title: 'Total Orders', value: '1,234', icon: 'mdi-cart', color: 'primary' },
  { title: 'Today Sales', value: '$3,456K', icon: 'mdi-currency-usd', color: 'success' },
  { title: 'Active Users', value: '567', icon: 'mdi-account-group', color: 'info' },
  { title: 'Pending Process', value: '89', icon: 'mdi-clock-alert', color: 'warning' }
])
</script>
```

BoundedContext Card Generation Logic:
```typescript
// Dynamically generate BoundedContext cards based on metadata
const generateBoundedContexts = (boundedContextsMetadata) => {
  return Object.keys(boundedContextsMetadata).map(contextKey => {
    const contextAggregates = boundedContextsMetadata[contextKey].aggregates || [];
    return {
      name: contextKey,
      path: `/${contextKey.toLowerCase()}`,
      aggregates: contextAggregates.map(aggregate => ({
        name: aggregate.name,
        namePlural: aggregate.namePlural,
        displayName: aggregate.displayName || aggregate.name
      }))
    };
  });
};

// Usage example
const boundedContexts = generateBoundedContexts(metaData.boundedContexts);

// Each BoundedContext card component
const BoundedContextCard = {
  props: ['contextName', 'contextPath', 'aggregates'],
  template: `
    <div class="context-card" @click="navigateToContext">
      <h3></h3>
      <p> Aggregates</p>
      <ul>
        <li v-for="aggregate in aggregates" :key="aggregate.name">
          
        </li>
      </ul>
    </div>
  `,
  methods: {
    navigateToContext() {
      this.$router.push(\`\${this.contextPath}/\${this.aggregates[0]?.namePlural || ''}\`);
    }
  }
};
```

2. BoundedContext-specific Submenus
Each BoundedContext is configured as an independent submenu that includes Aggregate List components of the corresponding context.

SubMenu.vue
Structure:
- Vue Router-based navigation
- Menu grouping by BoundedContext
- Accordion or tab-style menu
- Return to main page button

3. Routing Structure - Utilizing Vue Router 4

**router/index.js - Dynamic Routing Configuration**
```javascript
import { createRouter, createWebHistory } from 'vue-router'
import MainDashboard from '@/views/common/MainDashboard.vue'

// Generate dynamic routes based on metadata
const generateRoutes = (boundedContexts) => {
  const routes = []
  
  Object.entries(boundedContexts).forEach(([contextKey, contextData]) => {
    const contextRoute = {
      path: `/${contextKey.toLowerCase()}`,
      component: () => import(`@/layouts/BoundedContextLayout.vue`),
      meta: { context: contextKey },
      children: []
    }
    
    // Generate routes for each Aggregate
    contextData.aggregates?.forEach(aggregate => {
      contextRoute.children.push(
        {
          path: aggregate.namePlural,
          name: `${contextKey}-${aggregate.name}-list`,
          component: () => import(`@/views/${contextKey}/${aggregate.name}ListView.vue`),
          meta: { aggregate: aggregate.name }
        },
        {
          path: `${aggregate.namePlural}/:id`,
          name: `${contextKey}-${aggregate.name}-detail`,
          component: () => import(`@/views/${contextKey}/${aggregate.name}DetailView.vue`),
          meta: { aggregate: aggregate.name }
        }
      )
    })
    
    routes.push(contextRoute)
  })
  
  return routes
}

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      name: 'home',
      component: MainDashboard
    },
    ...generateRoutes(metaData.boundedContexts),
    {
      path: '/:pathMatch(.*)*',
      name: 'not-found',
      component: () => import('@/views/common/NotFound.vue')
    }
  ]
})

export default router
```

**App.vue - Vuetify Basic Layout**
```vue
<template>
  <v-app>
    <v-navigation-drawer
      v-model="drawer"
      app
    >
      <v-list nav>
        <v-list-item
          prepend-icon="mdi-view-dashboard"
          title="Dashboard"
          to="/"
        ></v-list-item>
        
        <v-list-group
          v-for="context in boundedContexts"
          :key="context.name"
          :value="context.name"
        >
          <template v-slot:activator="{ props }">
            <v-list-item
              v-bind="props"
              :prepend-icon="context.icon"
              :title="context.displayName"
            ></v-list-item>
          </template>
          
          <v-list-item
            v-for="agg in context.aggregates"
            :key="agg.name"
            :title="agg.displayName"
            :to="`/${context.name.toLowerCase()}/${agg.namePlural}`"
          ></v-list-item>
        </v-list-group>
      </v-list>
    </v-navigation-drawer>
    
    <v-app-bar app>
      <v-app-bar-nav-icon @click="drawer = !drawer"></v-app-bar-nav-icon>
      <v-toolbar-title>{{ systemName }}</v-toolbar-title>
      <v-spacer></v-spacer>
      
      <!-- User menu -->
      <v-btn icon="mdi-account-circle" size="large"></v-btn>
    </v-app-bar>
    
    <v-main>
      <router-view />
    </v-main>
    
    <!-- Global snackbar -->
    <v-snackbar
      v-model="snackbar.show"
      :color="snackbar.color"
      :timeout="snackbar.timeout"
    >
      {{ snackbar.text }}
      <template v-slot:actions>
        <v-btn
          variant="text"
          @click="snackbar.show = false"
        >
          Close
        </v-btn>
      </template>
    </v-snackbar>
  </v-app>
</template>
```

Main Page Card UI Configuration:
- Dynamic display of BoundedContext names based on metadata (utilizing contextKey)
- Dynamic display of Aggregate count within the corresponding context
- Aggregate list preview (utilizing aggregate.displayName or aggregate.name)
- Navigate to List page based on the first Aggregate's namePlural when clicked
- Universal structure that automatically reflects PRD changes
- When parameters from views or ReadModels exist, write query statements referencing queryOption