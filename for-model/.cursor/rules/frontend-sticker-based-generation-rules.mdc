---
description: Guidelines for configuring React components based on Metadata generated through DDD-based Event Storming.
alwaysApply: false
---

Please configure React component files by referring to the UI that should be generated for each Event Storming sticker below.
Important: Must be generated based only on Metadata, and should not arbitrarily create data not in Metadata.

1. Aggregate

Metadata: Generated by referencing data under aggregates

[Aggregate]Page.tsx - Aggregate CRUD UI (React page component)
Router: /[aggregates.namePlural] (React Router-based routing)
File names: [aggregates.name]Page.tsx, [aggregates.name]Form.tsx, [aggregates.name]Table.tsx

Included Elements
1) Create a query page in Material-UI DataGrid or Table format based on aggregate properties (aggregateRoot.fieldDescriptors), implement structure where queries are automatically triggered when entering the aggregate router
2) Identify className to create type-specific Material-UI components (TextField, Select, DatePicker...)
3) Always create action buttons according to CUD following JPA Repository (Create, Update, Delete - using Material-UI Button)
4) Create buttons according to Extend API (generated based on command info when commands.isRestRepository is false)
5) Create search bar functionality (when views.queryparameters exist - using Material-UI TextField)
6) For styles, refer to `@frontend-design-system` and utilize Material-UI sx props

[Aggregate]Form.tsx - Form UI for Create, Update following JPA Repository pattern
1) Create form as Material-UI Dialog or separate page connected through Create, Update buttons created in [Aggregate]Page.tsx. Also, APIs according to CRUD must reference openapi.yaml and be generated in JPA Repository format.
2) Form Fields create Material-UI input components based on aggregate properties
3) Identify className to create type-specific input forms (TextField, Select, DatePicker, Switch...)
4) Implement form validation using React Hook Form and Yup
5) For styles, refer to `@frontend-design-system` and utilize Material-UI theme system

React Component Example:
```typescript
// [Aggregate]Page.tsx
import React, { useState, useEffect } from 'react';
import { Box, Button, Typography, Card, CardContent } from '@mui/material';
import { Add, Edit, Delete } from '@mui/icons-material';
import [Aggregate]Table from './[Aggregate]Table';
import [Aggregate]Form from './[Aggregate]Form';

const [Aggregate]Page: React.FC = () => {
  const [items, setItems] = useState([]);
  const [formOpen, setFormOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  return (
    <Box sx=\{{ p: 3 }}>
      <Typography variant="h4" component="h1" gutterBottom>
        [Aggregate] Management
      </Typography>
      
      <Card>
        <CardContent>
          <Box sx=\{{ mb: 2, display: 'flex', justifyContent: 'space-between' }}>
            <Button
              variant="contained"
              startIcon={<Add />}
              onClick={() => setFormOpen(true)}
            >
              Create [Aggregate]
            </Button>
          </Box>
          
          <[Aggregate]Table 
            data={items}
            onEdit={setSelectedItem}
            onDelete={handleDelete}
          />
        </CardContent>
      </Card>
      
      <[Aggregate]Form
        open={formOpen}
        onClose={() => setFormOpen(false)}
        data={selectedItem}
        onSave={handleSave}
      />
    </Box>
  );
};
```
---

2. Command

Metadata: Generated by referencing data under commands
File names: [commands.namePascalCase]Button.tsx, [commands.namePascalCase]Modal.tsx

Included Elements
1) When Metadata isRestRepository is false, create additional Material-UI Button in [Aggregate]Page.tsx excluding CUD action buttons
2) Generate basic Material-UI Button, Dialog UI, styles by converting html code from `@frontend-ui-requirments` to React
3) APIs according to commands must reference openapi.yaml under boundedContext.
4) Implement command execution logic using React Hook pattern

React Component Example:
```typescript
// [Command]Button.tsx
import React, { useState } from 'react';
import { Button, Dialog, DialogTitle, DialogContent, DialogActions } from '@mui/material';
import { useCommandMutation } from '../hooks/use[Command]';

interface [Command]ButtonProps {
  targetId: string;
  onSuccess?: () => void;
}

const [Command]Button: React.FC<[Command]ButtonProps> = ({ targetId, onSuccess }) => {
  const [open, setOpen] = useState(false);
  const mutation = useCommandMutation();

  const handleExecute = async () => {
    try {
      await mutation.mutateAsync({ id: targetId });
      setOpen(false);
      onSuccess?.();
    } catch (error) {
      console.error('Command execution failed:', error);
    }
  };

  return (
    <>
      <Button variant="outlined" onClick={() => setOpen(true)}>
        Execute [Command]
      </Button>
      
      <Dialog open={open} onClose={() => setOpen(false)}>
        <DialogTitle>Confirm [Command]</DialogTitle>
        <DialogContent>
          Do you want to execute this action?
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setOpen(false)}>Cancel</Button>
          <Button onClick={handleExecute} variant="contained">
            Execute
          </Button>
        </DialogActions>
      </Dialog>
    </>
  );
};
```
---

3. ReadModel
Metadata: Generated by referencing data under views
File names: [views.namePascalCase]Search.tsx, [views.namePascalCase]Dashboard.tsx

[ReadModel]Search.tsx - Search UI that can search data registered in aggregate
1) Generate only when Metadata views.dataProjection: query-for-aggregate (absolutely should not be generated otherwise)
2) Implement SearchBar using Material-UI TextField searchable in [Aggregate]Page.tsx
3) Set search conditions based on views.queryParameters
4) Process so that conditions matching search conditions appear in Material-UI Table during search
5) Generate UI, styles by converting html code from `@frontend-ui-requirments` to React

[ReadModel]Dashboard.tsx - Dashboard UI that can view properties registered in ReadModel
Router: /[views.namePlural] (React Router-based routing)
1) Generate only when Metadata views.dataProjection: cqrs (absolutely should not be generated otherwise)
2) Implement view UI using Material-UI components based on data declared in fieldDescriptors
3) Generate UI, styles by converting html code from `@frontend-ui-requirments` to React

React Component Example:
```typescript
// [ReadModel]Dashboard.tsx
import React, { useState, useEffect } from 'react';
import { Box, Card, CardContent, Typography, Button, Grid } from '@mui/material';
import { Refresh } from '@mui/icons-material';
import { useQuery } from '@tanstack/react-query';

const [ReadModel]Dashboard: React.FC = () => {
  const { data, isLoading, refetch } = useQuery({
    queryKey: ['[readmodel]'],
    queryFn: fetch[ReadModel]Data,
  });

  return (
    <Box sx=\{{ p: 3 }}>
      <Box sx=\{{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
        <Typography variant="h4" component="h1">
          [ReadModel] Dashboard
        </Typography>
        <Button
          variant="outlined"
          startIcon={<Refresh />}
          onClick={() => refetch()}
        >
          Refresh
        </Button>
      </Box>

      <Grid container spacing={3}>
        {data?.map((item) => (
          <Grid item xs={12} sm={6} md={4} key={item.id}>
            <Card>
              <CardContent>
                <Typography variant="h6">{item.title}</Typography>
                <Typography variant="body2" color="text.secondary">
                  {item.description}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};
```
---

4. BoundedContext
Metadata: Generated by referencing boundedContexts data

HomePage.tsx (Root main page)
1) The main page is created based on the name of Metadata options.package and the router is set to Root (ex.localhost:3000/). Then, all aggregates names and routers must be connected to implement the Home page in Material-UI Card format.
2) When configuring left sidebar using Material-UI AppBar and Drawer, configure 2-Level with navigation to Home(Root), 1Level - boundedContext.name, 2Level - aggregates.name, views.name. Clicking should navigate to the corresponding page.

React Component Example:
```typescript
// HomePage.tsx
import React from 'react';
import { Box, Grid, Card, CardContent, Typography, CardActionArea } from '@mui/material';
import { useNavigate } from 'react-router-dom';

const HomePage: React.FC = () => {
  const navigate = useNavigate();

  const boundedContexts = [
    { name: 'Order', path: '/order', description: 'Order Management' },
    { name: 'CustomerCenter', path: '/customercenter', description: 'Customer Center' },
  ];

  return (
    <Box sx=\{{ p: 3 }}>
      <Typography variant="h3" component="h1" gutterBottom>
        OrderPage Management System
      </Typography>
      
      <Grid container spacing={3}>
        {boundedContexts.map((context) => (
          <Grid item xs={12} sm={6} md={4} key={context.name}>
            <Card>
              <CardActionArea onClick={() => navigate(context.path)}>
                <CardContent>
                  <Typography variant="h5" component="h2" gutterBottom>
                    {context.name}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {context.description}
                  </Typography>
                </CardContent>
              </CardActionArea>
            </Card>
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};
```

## React Component Creation Additional Guidelines

### 1. Type Definitions
All components should define TypeScript interfaces:
```typescript
interface [Component]Props {
  data?: any[];
  onSave?: (data: any) => void;
  onCancel?: () => void;
}
```

### 2. State Management
Utilize React Hook(useState, useEffect) and React Query:
```typescript
const { data, isLoading, error } = useQuery({
  queryKey: ['key'],
  queryFn: apiFunction,
});
```

### 3. Form Handling
Use React Hook Form combined with Material-UI:
```typescript
const { control, handleSubmit, formState: { errors } } = useForm();
```

### 4. Error Handling
Implement error handling using ErrorBoundary and try-catch.

### 5. Accessibility
Utilize Material-UI's basic accessibility features and add aria-labels.