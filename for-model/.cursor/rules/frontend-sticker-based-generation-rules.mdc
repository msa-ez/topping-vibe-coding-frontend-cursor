---
description: Guidelines for configuring React components based on Metadata generated through DDD-based Event Storming.
alwaysApply: false
---
Please configure React component files by referring to the UI that should be generated for each Event Storming sticker below.
Important: Must be generated based only on Metadata, and should not arbitrarily create data not in Metadata.

## API Endpoint Configuration
All API calls must follow the configuration defined in `@frontend-technical-stack` and `@frontend-generation-rules`:
- **Base URL**: Refer to `@frontend-technical-stack` for axios client configuration
- **Environment Variables**: Refer to `@frontend-generation-rules` for Gateway integration setup

1. Aggregate

Metadata: Generated by referencing data under aggregates

[Aggregate]Page.tsx - Aggregate CRUD UI (React page component)
Router: /[aggregates.namePlural] (React Router-based routing)
File names: [aggregates.name]Page.tsx, [aggregates.name]Form.tsx, [aggregates.name]Table.tsx

Included Elements
1) Create a query page in Material-UI DataGrid or Table format based on aggregate properties (aggregateRoot.fieldDescriptors), implement structure where queries are automatically triggered when entering the aggregate router
2) Identify className to create type-specific Material-UI components (TextField, Select, DatePicker...)
3) Always create action buttons according to CUD following JPA Repository (Create, Update, Delete - using Material-UI Button)
4) Create buttons according to Extend API (generated based on command info when commands.isRestRepository is false)
5) Create search bar functionality (when views.queryparameters exist - using Material-UI TextField)
6) For styles, refer to `@frontend-design-system` and utilize Material-UI sx props

[Aggregate]Form.tsx - Form UI for Create, Update following JPA Repository pattern
1) Create form as Material-UI Dialog or separate page connected through Create, Update buttons created in [Aggregate]Page.tsx. Also, APIs according to CRUD must reference openapi.yaml and be generated in JPA Repository format.
2) Form Fields create Material-UI input components based on aggregate properties
3) Identify className to create type-specific input forms (TextField, Select, DatePicker, Switch...)
4) Implement form validation using React Hook Form and Yup
5) For styles, refer to `@frontend-design-system` and utilize Material-UI theme system
6) **API Configuration**: Follow `@frontend-technical-stack` axios client setup

React Component Example:
```typescript
// [Aggregate]Page.tsx
import React, { useState, useEffect } from 'react';
import { Box, Button, Typography, Card, CardContent } from '@mui/material';
import { Add, Edit, Delete } from '@mui/icons-material';
import [Aggregate]Table from './[Aggregate]Table';
import [Aggregate]Form from './[Aggregate]Form';

const [Aggregate]Page: React.FC = () => {
  const [items, setItems] = useState([]);
  const [formOpen, setFormOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  return (
    <Box sx=\{{ p: 3 }}>
      <Typography variant="h4" component="h1" gutterBottom>
        [Aggregate] Management
      </Typography>
      
      <Card>
        <CardContent>
          <Box sx=\{{ mb: 2, display: 'flex', justifyContent: 'space-between' }}>
            <Button
              variant="contained"
              startIcon={<Add />}
              onClick={() => setFormOpen(true)}
            >
              Create [Aggregate]
            </Button>
          </Box>
          
          <[Aggregate]Table 
            data={items}
            onEdit={setSelectedItem}
            onDelete={handleDelete}
          />
        </CardContent>
      </Card>
      
      <[Aggregate]Form
        open={formOpen}
        onClose={() => setFormOpen(false)}
        data={selectedItem}
        onSave={handleSave}
      />
    </Box>
  );
};
```
---


2. Command

Metadata: Generated by referencing data under commands
File names: [commands.namePascalCase]Button.tsx, [commands.namePascalCase]Modal.tsx

Included Elements
1) When command Metadata isRestRepository is false, generate additional Material-UI buttons in [Aggregate]Page.tsx excluding CUD action buttons
2) Convert code from `@frontend-ui-requirements` to React and use the basic Material-UI button and dialog UI content as is.
3) APIs according to commands must use the same value as the path value in openapi.yaml under boundedContext. Values not in the path must not be created.
4) Implement command execution logic using React Hook pattern
5) **API Configuration**: Follow `@frontend-technical-stack` axios client configuration, and all API requests and responses must proceed in Spring Data REST API format.

ex. approve author command
Files to be created and modified: AuthorPage.tsx, ApproveAuthorButton.tsx, ApproveAuthorModal.tsx
---


3. ReadModel
Metadata: Generated by referencing data under views
File names: [views.namePascalCase]Search.tsx, [views.namePascalCase]Dashboard.tsx

[ReadModel]Search.tsx - Search UI that can search data registered in aggregate
1) Generate only when Metadata views.dataProjection: query-for-aggregate (absolutely should not be generated otherwise)
2) Implement SearchBar using Material-UI TextField searchable in [Aggregate]Page.tsx
3) Set search conditions based on views.queryParameters
4) Process so that conditions matching search conditions appear in Material-UI Table during search
5) Generate UI, styles by converting html code from `@frontend-ui-requirements` to React
6) **API Configuration**: Follow `@frontend-technical-stack` axios client setup

[ReadModel]Dashboard.tsx - Dashboard UI that can view properties registered in ReadModel
Router: /[views.namePlural] (React Router-based routing)
1) Generate only when Metadata views.dataProjection: cqrs (absolutely should not be generated otherwise)
2) Implement view UI using Material-UI components based on data declared in fieldDescriptors
3) Generate UI, styles by converting html code from `@frontend-ui-requirements` to React
4) **API Configuration**: Follow `@frontend-technical-stack` axios client setup

React Component Example:
```typescript
// [ReadModel]Dashboard.tsx
import React, { useState, useEffect } from 'react';
import { Box, Card, CardContent, Typography, Button, Grid } from '@mui/material';
import { Refresh } from '@mui/icons-material';
import { useQuery } from '@tanstack/react-query';

const [ReadModel]Dashboard: React.FC = () => {
  const { data, isLoading, refetch } = useQuery({
    queryKey: ['[readmodel]'],
    queryFn: fetch[ReadModel]Data,
  });

  return (
    <Box sx=\{{ p: 3 }}>
      <Box sx=\{{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
        <Typography variant="h4" component="h1">
          [ReadModel] Dashboard
        </Typography>
        <Button
          variant="outlined"
          startIcon={<Refresh />}
          onClick={() => refetch()}
        >
          Refresh
        </Button>
      </Box>

      <Grid container spacing={3}>
        {data?.map((item) => (
          <Grid item xs={12} sm={6} md={4} key={item.id}>
            <Card>
              <CardContent>
                <Typography variant="h6">{item.title}</Typography>
                <Typography variant="body2" color="text.secondary">
                  {item.description}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};
```
---


4. BoundedContext
Metadata: Generated by referencing boundedContexts data

HomePage.tsx (Root main page)
1) The main page is created based on the name of Metadata options.package and the router is set to Root (ex.localhost:3000/). Then, all aggregates names and routers must be connected to implement the Home page in Material-UI Card format.
2) When configuring left sidebar using Material-UI AppBar and Drawer, configure 2-Level with navigation to Home(Root), 1Level - boundedContext.name, 2Level - aggregates.name, views.name. Clicking should navigate to the corresponding page.

React Component Example:
```typescript
// HomePage.tsx
import React from 'react';
import { Box, Grid, Card, CardContent, Typography, CardActionArea } from '@mui/material';
import { useNavigate } from 'react-router-dom';

const HomePage: React.FC = () => {
  const navigate = useNavigate();

  const boundedContexts = [
    { name: 'Order', path: '/order', description: 'Order Management' },
    { name: 'CustomerCenter', path: '/customercenter', description: 'Customer Center' },
  ];

  return (
    <Box sx=\{{ p: 3 }}>
      <Typography variant="h3" component="h1" gutterBottom>
        OrderPage Management System
      </Typography>
      
      <Grid container spacing={3}>
        {boundedContexts.map((context) => (
          <Grid item xs={12} sm={6} md={4} key={context.name}>
            <Card>
              <CardActionArea onClick={() => navigate(context.path)}>
                <CardContent>
                  <Typography variant="h5" component="h2" gutterBottom>
                    {context.name}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {context.description}
                  </Typography>
                </CardContent>
              </CardActionArea>
            </Card>
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};
```

## React Component Creation Additional Guidelines

### 1. Type Definitions
All components should define TypeScript interfaces:
```typescript
interface [Component]Props {
  data?: any[];
  onSave?: (data: any) => void;
  onCancel?: () => void;
}
```

### 2. State Management
Refer to `@frontend-technical-stack` for React Hooks and React Query patterns.

### 3. Form Handling
Refer to `@frontend-technical-stack` for React Hook Form examples and patterns.

### 4. Error Handling
Implement error handling using ErrorBoundary and try-catch.

### 5. Accessibility
Utilize Material-UI's basic accessibility features and add aria-labels.

### 6. API Service Configuration
Use the API client configuration defined in `@frontend-technical-stack`.

### 7. Environment Variables
Refer to `@frontend-generation-rules` for environment variable configuration.