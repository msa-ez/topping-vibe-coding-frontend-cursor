---
description: Guidelines for composing React components based on metadata generated through DDD-based Event Storming.
alwaysApply: false
---
Please configure React component files by referring to the UI that should be generated for each Event Storming sticker below.
Important: Components must be generated based solely on metadata, and no arbitrary data not present in the metadata should be generated.

## API Endpoint Configuration
All API calls must follow the configurations defined in `@frontend-technical-stack` and `@frontend-generation-rules`:
- **Base URL**: Refer to `@frontend-technical-stack` for axios client configuration
- **Environment Variables**: Refer to `@frontend-generation-rules` for Gateway integration settings

1. Aggregate

Metadata: Generated by referencing data under aggregates

[Aggregate]Page.tsx - Aggregate CRUD UI (React page component)
Router: /[aggregates.namePlural] (React Router-based routing)
File names: [aggregates.name]Page.tsx, [aggregates.name]Form.tsx, [aggregates.name]Table.tsx

Included Elements
1) Generate a Material-UI DataGrid or Table format inquiry page based on aggregate properties (aggregateRoot.fieldDescriptors), and implement a structure where queries are automatically executed when entering the aggregate router
2) Generate type-specific Material-UI components by identifying className (TextField, Select, DatePicker...)
3) Always generate action buttons according to CUD following JPA Repository (Create, Update, Delete - using Material-UI Button)
4) Generate buttons according to Extend API (generated based on command information when commands.isRestRepository is false)
5) Generate search bar functionality (when views.queryparameters exist - using Material-UI TextField)
6) Refer to `@frontend-design-system` for styles and utilize Material-UI sx props

[Aggregate]Form.tsx - Create and edit form UI following JPA Repository pattern
1) Create forms as Material-UI Dialog or separate pages connected through Create and Update buttons generated in [Aggregate]Page.tsx. **CRUD API Generation Priority**:
   - **Priority 1**: When backend controller files exist (e.g., `infra/*Controller.java` or `*Repository.java`), generate frontend CRUD APIs that exactly match the backend's endpoint paths, HTTP methods, and request/response structures
   - **Priority 2**: When backend files don't exist, generate CRUD APIs following the paths and specifications defined by referencing the `openapi.yaml` file under boundedContext
   - **Default Pattern**: When neither source is available, follow JPA Repository format using plural naming conventions for each aggregate (e.g., GET /aggregates, POST /aggregates, PUT /aggregates/{id}, DELETE /aggregates/{id})
2) Generate Material-UI input components for form fields based on aggregate properties
3) Generate type-specific input forms by identifying className (TextField, Select, DatePicker, Switch...)
4) Implement form validation using React Hook Form and Yup
5) Refer to `@frontend-design-system` for styles and utilize Material-UI theme system
6) **API Configuration**: Follow `@frontend-technical-stack` axios client settings

React Component Example:
```typescript
// [Aggregate]Page.tsx
import React, { useState, useEffect } from 'react';
import { Box, Button, Typography, Card, CardContent } from '@mui/material';
import { Add, Edit, Delete } from '@mui/icons-material';
import [Aggregate]Table from './[Aggregate]Table';
import [Aggregate]Form from './[Aggregate]Form';

const [Aggregate]Page: React.FC = () => {
  const [items, setItems] = useState([]);
  const [formOpen, setFormOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  return (
    <Box sx=\{{ p: 3 }}>
      <Typography variant="h4" component="h1" gutterBottom>
        [Aggregate] Management
      </Typography>
      
      <Card>
        <CardContent>
          <Box sx=\{{ mb: 2, display: 'flex', justifyContent: 'space-between' }}>
            <Button
              variant="contained"
              startIcon={<Add />}
              onClick={() => setFormOpen(true)}
            >
              Create [Aggregate]
            </Button>
          </Box>
          
          <[Aggregate]Table 
            data={items}
            onEdit={setSelectedItem}
            onDelete={handleDelete}
            sx=\{{ width: '100%' }}
          />
        </CardContent>
      </Card>
      
      <[Aggregate]Form
        open={formOpen}
        onClose={() => setFormOpen(false)}
        data={selectedItem}
        onSave={handleSave}
      />
    </Box>
  );
};
```
---
2. Command

Metadata: Generated by referencing data under commands
File names: [commands.namePascalCase]Button.tsx, [commands.namePascalCase]Modal.tsx

Included Elements
1) When command metadata's isRestRepository is false, generate additional Material-UI buttons in [Aggregate]Page.tsx excluding CUD action buttons
2) Convert code from BoundedContext Name/Aggregate Name/AggregateWireframe.md to React and use the basic Material-UI button and dialog UI content as is. At this time, all components generated in the wireframe must be created without omission.
3) **API Endpoint Generation Priority**: For command-based APIs, follow the following hierarchy to ensure frontend APIs match backend implementation:
   - **Priority 1**: When backend controller files exist (e.g., `infra/*Controller.java` under boundedContext), generate frontend API calls that exactly match the controller's endpoint paths, HTTP methods, and parameter structures
   - **Priority 2**: When backend controller files don't exist, use the exact path values defined by referencing the `openapi.yaml` file under boundedContext (e.g., `/orders/{id}/cancelorder`, `/orders/{id}/acceptorder`)
   - **Limitation**: Only generate API endpoints explicitly defined in controller files or openapi.yaml. Do not generate arbitrary or inferred endpoints not documented in these sources
4) Implement command execution logic using React Hook patterns
5) **API Configuration**: Follow `@frontend-technical-stack` axios client configuration, and all API requests and responses proceed in Spring Data REST API format

Example: Author Approval Command when isRestRepository:false - Required Order
Files to create and modify: AuthorPage.tsx, ApproveAuthorButton.tsx, ApproveAuthorModal.tsx
1. **API Endpoint Discovery**: First check if `infra/AuthorController.java` exists and find approval-related endpoints (e.g., `@PostMapping("/authors/{id}/approve")`). If no controller exists, check author approval paths in `openapi.yaml`
2. Convert HTML code listed in BoundedContext Name/Aggregate Name/AggregateWireframe.md to React
3. Generate button UI in CommandButton.tsx with API calls matching the discovered endpoints
4. When creating buttons, implement conditional rendering that is activated through table row clicks
5. Generate modal-related UI in CommandModal.tsx
6. Create a button in AggregatePage.tsx with the same style as the registration button to call CommandButton.tsx, then connect to CommandButton
```
<Button
  variant="contained"
  startIcon={<AddIcon />}
  onClick={handleAddAuthor}
>
  Author Approval
</Button>
```
---

3. ReadModel
Metadata: Generated by referencing data under views
File names: [views.namePascalCase]Search.tsx, [views.namePascalCase]Dashboard.tsx

[ReadModel]Search.tsx - Search UI that can search data registered in aggregates
1) Generate only when metadata views.dataProjection: query-for-aggregate (never generate otherwise)
2) Implement SearchBar using searchable Material-UI TextField in [Aggregate]Page.tsx
3) Set search conditions based on views.queryParameters
4) Process so that conditions matching search criteria appear in Material-UI Table when searching
5) Convert html code from BoundedContext Name/Aggregate Name/AggregateWireframe.md to React to generate UI and styles
6) **API Configuration**: Follow `@frontend-technical-stack` axios client settings and apply the same API endpoint generation priority as defined in the Command section (controller files first, then openapi.yaml)

[ReadModel]Dashboard.tsx - Dashboard UI to view properties registered in ReadModel
Router: /[views.namePlural] (React Router-based routing)
1) Generate only when metadata views.dataProjection: cqrs (never generate otherwise)
2) Implement view UI using Material-UI components based on data declared in fieldDescriptors
3) Convert html code from BoundedContext Name/Aggregate Name/AggregateWireframe.md to React to generate UI and styles
4) **API Configuration**: Follow `@frontend-technical-stack` axios client settings and apply the same API endpoint generation priority as defined in the Command section (controller files first, then openapi.yaml)

React Component Example:
```typescript
// [ReadModel]Dashboard.tsx
import React, { useState, useEffect } from 'react';
import { Box, Card, CardContent, Typography, Button, Grid } from '@mui/material';
import { Refresh } from '@mui/icons-material';
import { useQuery } from '@tanstack/react-query';

const [ReadModel]Dashboard: React.FC = () => {
  const { data, isLoading, refetch } = useQuery({
    queryKey: ['[readmodel]'],
    queryFn: fetch[ReadModel]Data,
  });

  return (
    <Box sx=\{{ p: 3 }}>
      <Box sx=\{{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
        <Typography variant="h4" component="h1">
          [ReadModel] Dashboard
        </Typography>
        <Button
          variant="outlined"
          startIcon={<Refresh />}
          onClick={() => refetch()}
        >
          Refresh
        </Button>
      </Box>

      <Grid container spacing={3}>
        {data?.map((item) => (
          <Grid item xs={12} sm={6} md={4} key={item.id}>
            <Card>
              <CardContent>
                <Typography variant="h6">{item.title}</Typography>
                <Typography variant="body2" color="text.secondary">
                  {item.description}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};
```
---


4. BoundedContext
Metadata: Generated by referencing boundedContexts data

HomePage.tsx (Root main page)
1) Generate a main page based on the name of metadata options.package and set the router to Root (e.g., localhost:3000/). Then implement the Home page in Material-UI Card format by connecting all aggregates names and routers.
2) When configuring the left sidebar using Material-UI AppBar and Drawer, configure 2-level navigation with Home(Root), 1Level - boundedContext.name, 2Level - aggregates.name, views.name. It should navigate to the corresponding page when clicked.

React Component Example:
```typescript
// HomePage.tsx
import React from 'react';
import { Box, Grid, Card, CardContent, Typography, CardActionArea } from '@mui/material';
import { useNavigate } from 'react-router-dom';

const HomePage: React.FC = () => {
  const navigate = useNavigate();

  const boundedContexts = [
    { name: 'Order', path: '/order', description: 'Order Management' },
    { name: 'CustomerCenter', path: '/customercenter', description: 'Customer Center' },
  ];

  return (
    <Box sx=\{{ p: 3 }}>
      <Typography variant="h3" component="h1" gutterBottom>
        Order Management System
      </Typography>
      
      <Grid container spacing={3}>
        {boundedContexts.map((context) => (
          <Grid item xs={12} sm={6} md={4} key={context.name}>
            <Card>
              <CardActionArea onClick={() => navigate(context.path)}>
                <CardContent>
                  <Typography variant="h5" component="h2" gutterBottom>
                    {context.name}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {context.description}
                  </Typography>
                </CardContent>
              </CardActionArea>
            </Card>
          </Grid>
        ))}
      </Grid>
    </Box>
  );
};
```

## Additional Guidelines for React Component Generation

### 1. Type Definition
All components must define TypeScript interfaces:
```typescript
interface [Component]Props {
  data?: any[];
  onSave?: (data: any) => void;
  onCancel?: () => void;
}
```

### 2. State Management
Refer to `@frontend-technical-stack` for React Hooks and React Query patterns.

### 3. Form Handling
Refer to `@frontend-technical-stack` for React Hook Form examples and patterns.

### 4. Error Handling
Implement error handling using ErrorBoundary and try-catch.

### 5. Accessibility
Utilize Material-UI's basic accessibility features and add aria-labels.

### 6. API Service Configuration
Use the API client configuration defined in `@frontend-technical-stack`.

### 7. Environment Variables
Refer to `@frontend-generation-rules` for environment variable configuration.

### 8. Commands
When generating components based on commands metadata, follow Command generation requirements and openapi.yaml when isRestRepository:false.