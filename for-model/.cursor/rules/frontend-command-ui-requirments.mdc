---
description: 기초적인 Vue3 구조의 컴포넌트예시를 통해 제공된 HTML코드를 Vue3로 변환하여 BoundedContext내부에 구성되는 Aggregate별 Command와 관련하여 생성되어야 하는 UI에 대한 통일된 구조의 컴포넌트 가이드라인을 제공합니다.
alwaysApply: false
---


1. Button

```
<template>
  <v-btn @click="handleClick" color="primary">
    Click Me
  </v-btn>
</template>

<script setup>
const handleClick = () => {
  console.log('Button clicked!')
}
</script>
```

2. Dialog
```
<template>
  <div>
    <v-btn @click="dialog = true" color="primary">
      Open Dialog
    </v-btn>
    
    <v-dialog v-model="dialog" max-width="400">
      <v-card>
        <v-card-title>Dialog Title</v-card-title>
        <v-card-text>Dialog content goes here.</v-card-text>
        <v-card-actions>
          <v-spacer></v-spacer>
          <v-btn @click="dialog = false">Cancel</v-btn>
          <v-btn @click="confirm" color="primary">OK</v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const dialog = ref(false)

const confirm = () => {
  console.log('Confirmed!')
  dialog.value = false
}
</script>
```

3. Snackbar
```
<template>
  <div>
    <v-btn @click="showSnackbar" color="primary">
      Show Notification
    </v-btn>
    
    <v-snackbar v-model="snackbar" timeout="3000">
      {{ message }}
      <template v-slot:actions>
        <v-btn @click="snackbar = false">Close</v-btn>
      </template>
    </v-snackbar>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const snackbar = ref(false)
const message = ref('This is a notification!')

const showSnackbar = () => {
  snackbar.value = true
}
</script>
```
아래 생성된 Command에 따른 UI HTML코드는 위에 제공된 Vue3 구조의 기초되는 컴포넌트를 참고하여 변환되어야 한다.
이때 각 생성되는 파일의 위치는 @frontend-package-structure를 참고하며, 그에 따른 style은 @frontend-design-system을 참고하여 코드를 생성해야한다.
{{#if boundedContexts}}
{{#boundedContexts}}
{{#attached 'UI' this}}
BoundedContext: {{boundedContext.name}}
{{#attached 'Command'this}}
Attached Command Name: {{name}}
```
{{#changeData ../runTimeTemplateHtml}}{{/changeData}}
```
{{/attached}}

{{/attached}}
{{/boundedContexts}}
{{/if}}

<function>
window.$HandleBars.registerHelper('changeData', function (desc) {
    // HTML 엔티티를 실제 HTML 문자로 디코딩
    if (typeof desc === 'string') {
        let decodedHtml = desc
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#x3D;/g, '=')
            .replace(/&amp;/g, '&')
            .replace(/&#39;/g, "'")
            .replace(/&nbsp;/g, ' ');
        
        // HTML 포맷팅 함수
        function formatHtml(html) {
            let formatted = '';
            let indent = 0;
            const indentStr = '  '; // 2칸 들여쓰기
            
            // 블록 레벨 태그들
            const blockTags = ['div', 'section', 'article', 'header', 'footer', 'main', 'nav', 'aside', 'form', 'fieldset', 'table', 'thead', 'tbody', 'tr', 'ul', 'ol', 'li', 'dl', 'dt', 'dd', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'blockquote', 'pre', 'address'];
            
            // 자가 닫힘 태그들
            const selfClosingTags = ['img', 'br', 'hr', 'input', 'meta', 'link', 'area', 'base', 'col', 'embed', 'source', 'track', 'wbr'];
            
            // HTML을 태그 단위로 분리
            const tokens = html.match(/<\/?[^>]+>|[^<]+/g) || [];
            
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i].trim();
                if (!token) continue;
                
                if (token.startsWith('</')) {
                    // 닫는 태그
                    indent--;
                    formatted += indentStr.repeat(Math.max(0, indent)) + token + '\n';
                } else if (token.startsWith('<')) {
                    // 여는 태그 또는 자가 닫힘 태그
                    const tagMatch = token.match(/<(\w+)/);
                    const tagName = tagMatch ? tagMatch[1].toLowerCase() : '';
                    
                    formatted += indentStr.repeat(indent) + token + '\n';
                    
                    // 자가 닫힘 태그가 아니고 블록 태그인 경우 들여쓰기 증가
                    if (!selfClosingTags.includes(tagName) && !token.endsWith('/>')) {
                        indent++;
                    }
                } else {
                    // 텍스트 내용
                    if (token.length > 0) {
                        formatted += indentStr.repeat(indent) + token + '\n';
                    }
                }
            }
            
            return formatted.trim();
        }
        
        // HTML 포맷팅 적용
        return formatHtml(decodedHtml);
    }
    return desc;
})
</function>