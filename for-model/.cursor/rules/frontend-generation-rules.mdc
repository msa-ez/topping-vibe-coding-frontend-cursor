---


description: Defines metadata-driven component generation rules for React + TypeScript projects. Focuses on Event Storming sticker-based development process beyond basic project setup.
globs: Frontend-PRD.txt
alwaysApply: false
---


# Metadata-Driven Frontend Component Generation Rules

This rule defines the process of generating components based on Event Storming metadata when the basic project structure has already been created.

**Prerequisites**: 
- Basic frontend project has been generated through `frontend-setup-prd.md`
- Basic structure defined in `@frontend-package-structure` and `@frontend-technical-stack` has been set up

## Metadata-Based Component Generation Sequence

```
Metadata Analysis → BoundedContext Folder Creation → Aggregate-based Component Generation → Command Component Generation (Conditional) → ReadModel Component Generation (Conditional) → Routing Setup → API Service Integration → Type Definition Synchronization → Component Testing
```

## Metadata Analysis Requirements

### 1. Metadata Priority
1. **aggregates**: Required - Foundation for all CRUD components
2. **commands**: Conditional - Generate only when `isRestRepository: false`
3. **views**: Conditional - Generate based on `dataProjection` value
4. **boundedContexts**: Required - Foundation for folder structure and routing

### 2. Generation Condition Validation
```typescript
// Metadata validation logic example
const shouldCreateCommand = (command: CommandMetadata) => {
  return command.isRestRepository === false
}

const shouldCreateSearch = (view: ViewMetadata) => {
  return view.dataProjection === 'query-for-aggregate' && 
         view.queryParameters && view.queryParameters.length > 0
}

const shouldCreateDashboard = (view: ViewMetadata) => {
  return view.dataProjection === 'cqrs' && 
         view.fieldDescriptors && view.fieldDescriptors.length > 0
}
```

## Step-by-Step Component Generation Process

### Step 1: Metadata Analysis and Validation
```typescript
// Metadata validation and analysis
interface GenerationPlan {
  boundedContexts: string[]
  aggregateComponents: ComponentPlan[]
  commandComponents: ComponentPlan[]
  viewComponents: ComponentPlan[]
}

const analyzeMetadata = (metadata: EventStormingMetadata): GenerationPlan => {
  const plan: GenerationPlan = {
    boundedContexts: metadata.boundedContexts.map(bc => bc.name),
    aggregateComponents: [],
    commandComponents: [],
    viewComponents: []
  }

  // Aggregate-based component planning
  metadata.aggregates.forEach(aggregate => {
    plan.aggregateComponents.push({
      boundedContext: aggregate.boundedContext,
      name: aggregate.name,
      namePlural: aggregate.namePlural,
      components: ['Page', 'Form', 'Table', 'Card'],
      services: ['service', 'types', 'store', 'hook']
    })
  })

  // Command-based component planning (conditional)
  metadata.commands
    .filter(cmd => cmd.isRestRepository === false)
    .forEach(command => {
      plan.commandComponents.push({
        boundedContext: command.boundedContext,
        name: command.namePascalCase,
        targetAggregate: command.targetAggregate,
        components: ['Button', 'Modal'],
        services: ['service', 'types', 'hook']
      })
    })

  // View-based component planning (conditional)
  metadata.views.forEach(view => {
    if (shouldCreateSearch(view)) {
      plan.viewComponents.push({
        type: 'search',
        name: view.name,
        components: ['Search'],
        services: ['service', 'types', 'hook']
      })
    }
    
    if (shouldCreateDashboard(view)) {
      plan.viewComponents.push({
        type: 'dashboard',
        name: view.name,
        namePlural: view.namePlural,
        components: ['Dashboard', 'Page'],
        services: ['service', 'types', 'hook']
      })
    }
  })

  return plan
}
```

### Step 2: BoundedContext Folder Structure Creation
```typescript
// Folder structure creation
const createBoundedContextStructure = (boundedContext: string) => {
  const folders = [
    `src/components/${boundedContext}`,
    `src/pages/${boundedContext}`,
    `src/hooks/${boundedContext}`,
    `src/services/${boundedContext}`,
    `src/store/${boundedContext}`,
    `src/types/${boundedContext}`
  ]
  
  folders.forEach(folder => {
    // Folder creation logic
    console.log(`Creating folder: ${folder}`)
  })
}
```

### Step 3: Aggregate-based Component Generation
```typescript
// Aggregate component generation rules
const generateAggregateComponents = (aggregate: AggregateMetadata) => {
  const components = [
    {
      name: `${aggregate.name}Page.tsx`,
      template: 'aggregate-page',
      path: `src/components/${aggregate.boundedContext}`
    },
    {
      name: `${aggregate.name}Form.tsx`,
      template: 'aggregate-form',
      path: `src/components/${aggregate.boundedContext}`
    },
    {
      name: `${aggregate.name}Table.tsx`,
      template: 'aggregate-table',
      path: `src/components/${aggregate.boundedContext}`
    },
    {
      name: `${aggregate.name}Card.tsx`,
      template: 'aggregate-card',
      path: `src/components/${aggregate.boundedContext}`
    }
  ]
  
  // Service files
  const services = [
    {
      name: `${aggregate.name.toLowerCase()}.service.ts`,
      template: 'aggregate-service',
      path: `src/services/${aggregate.boundedContext}`
    },
    {
      name: `${aggregate.name.toLowerCase()}.types.ts`,
      template: 'aggregate-types',
      path: `src/types/${aggregate.boundedContext}`
    },
    {
      name: `${aggregate.name.toLowerCase()}.store.ts`,
      template: 'aggregate-store',
      path: `src/store/${aggregate.boundedContext}`
    },
    {
      name: `use${aggregate.name}.ts`,
      template: 'aggregate-hook',
      path: `src/hooks/${aggregate.boundedContext}`
    }
  ]
  
  return [...components, ...services]
}
```

### Step 4: Command-based Component Generation (Conditional)
```typescript
// Command component generation (only when isRestRepository: false)
const generateCommandComponents = (command: CommandMetadata) => {
  if (command.isRestRepository !== false) return []

  const components = [
    {
      name: `${command.namePascalCase}Button.tsx`,
      template: 'command-button',
      path: `src/components/${command.boundedContext}`
    },
    {
      name: `${command.namePascalCase}Modal.tsx`,
      template: 'command-modal',
      path: `src/components/${command.boundedContext}`
    }
  ]

  const services = [
    {
      name: `${command.name.toLowerCase()}.service.ts`,
      template: 'command-service',
      path: `src/services/${command.boundedContext}`
    },
    {
      name: `${command.name.toLowerCase()}.types.ts`,
      template: 'command-types',
      path: `src/types/${command.boundedContext}`
    },
    {
      name: `use${command.namePascalCase}.ts`,
      template: 'command-hook',
      path: `src/hooks/${command.boundedContext}`
    }
  ]

  return [...components, ...services]
}
```

### Step 5: ReadModel/View-based Component Generation (Conditional)
```typescript
// View component generation (conditional based on dataProjection)
const generateViewComponents = (view: ViewMetadata) => {
  const components = []
  const services = []

  // Search component (query-for-aggregate + queryParameters exist)
  if (shouldCreateSearch(view)) {
    components.push({
      name: `${view.name}Search.tsx`,
      template: 'view-search',
      path: `src/components/${view.boundedContext}/search`
    })
  }

  // Dashboard component (cqrs + fieldDescriptors exist)
  if (shouldCreateDashboard(view)) {
    components.push(
      {
        name: `${view.name}Dashboard.tsx`,
        template: 'view-dashboard',
        path: `src/components/${view.boundedContext}/dashboard`
      },
      {
        name: `${view.name}Page.tsx`,
        template: 'view-page',
        path: `src/pages/${view.boundedContext}/${view.namePlural}`
      }
    )
  }

  // Common service files
  if (components.length > 0) {
    services.push(
      {
        name: `${view.name.toLowerCase()}.service.ts`,
        template: 'query-service',
        path: `src/services/${view.boundedContext}`
      },
      {
        name: `${view.name.toLowerCase()}.types.ts`,
        template: 'query-types',
        path: `src/types/${view.boundedContext}`
      },
      {
        name: `use${view.name}.ts`,
        template: 'view-hook',
        path: `src/hooks/${view.boundedContext}`
      }
    )
  }

  return [...components, ...services]
}
```

### Step 6: Routing Setup (Metadata-based)
```typescript
// Automatic routing generation
const generateRouting = (metadata: EventStormingMetadata) => {
  const routes = []

  // BoundedContext routes
  metadata.boundedContexts.forEach(bc => {
    routes.push(`/${bc.name.toLowerCase()}`)
  })

  // Aggregate routes
  metadata.aggregates.forEach(aggregate => {
    routes.push(`/${aggregate.boundedContext.toLowerCase()}/${aggregate.namePlural.toLowerCase()}`)
  })

  // View routes (CQRS)
  metadata.views
    .filter(view => view.dataProjection === 'cqrs')
    .forEach(view => {
      routes.push(`/${view.namePlural.toLowerCase()}`)
    })

  return routes
}
```

## Component Generation Validation & Quality Assurance

### Metadata Validation Checklist
- [ ] **Aggregates**: name, namePlural, fieldDescriptors are defined for all aggregates
- [ ] **Commands**: isRestRepository value is clearly defined
- [ ] **Views**: dataProjection value is set to either 'cqrs' or 'query-for-aggregate'
- [ ] **BoundedContexts**: All BCs have unique names

### Component Generation Validation
- [ ] **Aggregate Components**: All Page, Form, Table, Card components are generated
- [ ] **Command Components**: Button, Modal generated only for Commands with isRestRepository: false
- [ ] **Search Components**: Search generated only for Views with queryParameters
- [ ] **Dashboard Components**: Dashboard generated only for CQRS Views with fieldDescriptors

### File Structure Validation
- [ ] **Folder Structure**: components, pages, hooks, services, store, types folders created for each BoundedContext
- [ ] **Naming Convention**: File names follow metadata's PascalCase, camelCase, namePlural rules
- [ ] **Import Paths**: All components import with correct relative paths

### API Integration Validation
- [ ] **Service Files**: Service files generated for each aggregate, command, view
- [ ] **Type Definitions**: TypeScript types defined based on metadata's fieldDescriptors
- [ ] **HAL JSON**: Spring Data REST response format correctly transformed

### Routing Validation
- [ ] **BoundedContext Routes**: Generated in /{boundedContext} format
- [ ] **Aggregate Routes**: Generated in /{boundedContext}/{aggregates.namePlural} format
- [ ] **View Routes**: Generated in /{views.namePlural} format for CQRS views

### Error Prevention Guidelines
1. **Missing Metadata**: Skip component generation for metadata lacking required fields
2. **Duplicate Prevention**: Confirm overwrite when components with same name already exist
3. **Dependency Order**: Generate in order: Type definitions → Services → Hooks → Components
4. **Import Check**: Validate that all generated files have valid import paths

**Important**: All component generation must be based strictly on metadata, and no content not defined in metadata should be generated.