---
description: Defines metadata-based component generation rules for React + TypeScript projects. Focuses on Event Storming sticker-based development processes beyond basic project setup.
globs: Frontend-PRD.txt
alwaysApply: false
---
# Metadata-Based Frontend Component Generation Rules

This rule defines the process of generating components based on Event Storming metadata when the basic project structure has already been created.

**Prerequisites**: 
- Basic frontend project has been created through `frontend-setup-prd.md`
- Basic structure has been set up through `frontend-setup-prd.md`

## Metadata-Based Component Generation Order
```
Metadata Analysis → BoundedContext Folder Creation → Aggregate-Based Component Generation → API Endpoint Discovery → Command Component Generation (Conditional) → ReadModel Component Generation (Conditional) → Routing Setup → Environment Variables & Gateway Configuration
```

## Step-by-Step Component Generation Process

### Step 1: Metadata Analysis and Validation
- **Aggregate Components**: Generate Page, Form, Table, Card + service, types, store, hook
- **Command Components**: Generate Button, Modal only when `isRestRepository: false`
- **View Components**: Generate Dashboard when `dataProjection: 'cqrs'`, Generate Search when `query-for-aggregate`

### Step 2: BoundedContext Folder Structure Creation
Create folders for each BoundedContext: `src/components/[BC]`, `src/pages/[BC]`, `src/hooks/[BC]`, `src/services/[BC]`, `src/store/[BC]`, `src/types/[BC]`

### Step 3: Aggregate-Based Component Generation
Generate CRUD component sets for each aggregate:
- **Components**: `[Aggregate]Page.tsx`, `[Aggregate]Form.tsx`, `[Aggregate]Table.tsx`, `[Aggregate]Card.tsx`
- **Services**: `[aggregate].service.ts`, `[aggregate].types.ts`, `[aggregate].store.ts`, `use[Aggregate].ts`

### Step 4: API Endpoint Discovery
When discovering command-related components and API Endpoints to be generated in Step 5, consider the following priority:
- Priority 1: Analyze API Endpoints according to Commands to be generated through analysis of infra/Controller.java files under services created with BoundedContext.name
- Priority 2: If Controller.java does not exist, analyze API Endpoints based on openapi.yaml under each service

### Step 5: Command-Based Component Generation (Conditional)
Generate only commands with `isRestRepository: false`:
- **Components**: `[Command]Button.tsx`, `[Command]Modal.tsx`  
- **Services**: `[command].service.ts`, `[command].types.ts`, `use[Command].ts`

### Step 6: ReadModel/View-Based Component Generation (Conditional)
- **Search**: When `dataProjection: 'query-for-aggregate'` + `queryParameters` exist → `[View]Search.tsx`
- **Dashboard**: When `dataProjection: 'cqrs'` + `fieldDescriptors` exist → `[View]Dashboard.tsx`, `[View]Page.tsx`

### Step 7: Routing Setup (Metadata-Based)
- **BC Route**: `/${boundedContext.name}`
- **Aggregate Route**: `/${boundedContext}/${aggregate.namePlural}`  
- **View Route**: `/${view.namePlural}` (CQRS only)

### Step 8: Environment Variables & Gateway Configuration
- **Environment Setup**: Set `VITE_GATEWAY_URL=http://localhost:8088` in `.env`, `.env.development`, `.env.production`
- Gateway route setup: Specify the generated Frontend endpoint (e.g., localhost:3000) in `application.yaml` route
- **API Path Validation**: Aggregate → `/${aggregate.namePlural}`, Command → `/${aggregate.namePlural}/{id}/{command.name}`

## Generation Guidelines

### Key Requirements
- All component generation must be strictly based on metadata
- Generate components only when required metadata fields exist
- Follow dependency order: Types → Services → Hooks → Components

### Error Handling
- Skip generation for incomplete metadata
- Confirm overwriting of existing components

### Validation Steps
```bash
# Check if Gateway and frontend are running
curl http://localhost:8088/actuator/health
npm run dev
```

### Validation Checklist
1. **Gateway Connection**: Verify access to `localhost:8088`
2. **Environment Variables**: Confirm `VITE_GATEWAY_URL` is set in `.env`
3. **Route Access**: Verify all generated pages load properly
4. **API Integration**: Confirm CRUD and command operations work

### Troubleshooting
- **CORS Error**: Check Gateway CORS configuration
- **404 Error**: Verify backend controller paths match frontend service paths
- **Connection Refused**: Confirm Gateway is running on port 8088